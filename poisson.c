// This code conforms with the UFC specification version 2018.2.0.dev0
// and was automatically generated by FFCX version 2019.2.0.dev0.
//
// This code was generated with the following parameters:
//
//  {'epsilon': 1e-14,
//   'external_includes': '',
//   'precision': -1,
//   'quadrature_degree': -1,
//   'quadrature_rule': 'auto',
//   'representation': 'auto',
//   'scalar_type': 'double',
//   'tabulate_tensor_void': False}


typedef double ufc_scalar_t;                   
#include <math.h>
#include <stdalign.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <ufc.h>



void tabulate_tensor_integral_cell_otherwise_b67e00d4067e0c970c3a0a79f0d0600104ce7791(ufc_scalar_t* A,
                                    const ufc_scalar_t* w,
                                    const ufc_scalar_t* c,
                                    const double* coordinate_dofs,
                                    const int*  unused_local_index,
                                    const uint8_t* quadrature_permutation,
                                    const uint32_t cell_permutation)
{
    // Quadrature rules
    alignas(32) static const double weights3[3] = { 0.1666666666666667, 0.1666666666666667, 0.1666666666666667 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [permutation][entities][points][dofs]
    alignas(32) static const double FE3_C0_Q3[1][1][3][3] =
        { { { { 0.6666666666666667, 0.1666666666666666, 0.1666666666666667 },
              { 0.1666666666666667, 0.1666666666666666, 0.6666666666666665 },
              { 0.1666666666666666, 0.6666666666666666, 0.1666666666666666 } } } };
    alignas(32) static const double FE4_C0_D01_Q3[1][1][1][3] = { { { { -1.0, 0.0, 1.0 } } } };
    alignas(32) static const double FE4_C0_D10_Q3[1][1][1][2] = { { { { -1.0, 1.0 } } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE4_C0_D10_Q3[0][0][0][0] + coordinate_dofs[2] * FE4_C0_D10_Q3[0][0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE4_C0_D01_Q3[0][0][0][0] + coordinate_dofs[3] * FE4_C0_D01_Q3[0][0][0][1] + coordinate_dofs[5] * FE4_C0_D01_Q3[0][0][0][2];
    const double J_c1 = coordinate_dofs[0] * FE4_C0_D01_Q3[0][0][0][0] + coordinate_dofs[2] * FE4_C0_D01_Q3[0][0][0][1] + coordinate_dofs[4] * FE4_C0_D01_Q3[0][0][0][2];
    const double J_c2 = coordinate_dofs[1] * FE4_C0_D10_Q3[0][0][0][0] + coordinate_dofs[3] * FE4_C0_D10_Q3[0][0][0][1];
    alignas(32) ufc_scalar_t sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = sp[2];
    if (sp[3] < 0)
      sp[3] = -sp[2];
    for (int iq = 0; iq < 3; ++iq)
    {
        // Quadrature loop body setup (num_points=3)
        // Unstructured varying computations for num_points=3
        ufc_scalar_t w0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0 += w[ic] * FE3_C0_Q3[0][0][iq][ic];
        alignas(32) ufc_scalar_t sv3[1];
        sv3[0] = sp[3] * w0;
        const ufc_scalar_t fw0 = sv3[0] * weights3[iq];
        for (int i = 0; i < 3; ++i)
            A[i] += fw0 * FE3_C0_Q3[0][0][iq][i];
    }
}
